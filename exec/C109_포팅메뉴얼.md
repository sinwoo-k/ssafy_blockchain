
## 목차

[1. 개발 환경](https://www.notion.so/19fd7c324ea380bb99c5c647e77060b9?pvs=21)

[2. EC2 서버 설정](https://www.notion.so/19fd7c324ea380bb99c5c647e77060b9?pvs=21)

[3. properties 파일](https://www.notion.so/19fd7c324ea380bb99c5c647e77060b9?pvs=21)

**[사용 도구]**

- 이슈 관리 : JIRA
- 형상 관리 : GitLab
- 커뮤니케이션 : Mattermost, Notion
- 디자인 : Figma
- CI/CD : EC2, Docker, Jenkins

## 1. 개발 환경

### Infra

- AWS EC2
- Ubuntu 22.04.4 LTS
- JVM: Bellsoft/liberica-openjdk-alpine:17.0.13
- 웹서버: nginx version: nginx/1.27.3
- WAS (Web Application Server): Tomcat

### Backend

- Java: `openjdk 17.0.13`
- Spring Boot: `3.4.3`
- Spring Dependency Management: `1.1.5`
- Build Tool: `Maven`
- IntelliJ IDEA: 2024.1.4
- Truffle : `5.11.51
- Solidity : `0.8.17`
- Web3.js : `1.10.0`
- Node : `18.20.7`
- express.js : `5.1.0`

### Frontend

- Node: `^20.18.1`
- React: `^19.0.0`

### Database

- MySQL : `8.0.41`
- Redis :

### Storage

- AWS S3

## 2. EC2 서버 설정

### 필수 패키지 설정 및 Docker 패키지 설치

1. **패키지 목록 업데이트**
    
    우분투 시스템의 패키지 목록을 최신 상태로 업데이트합니다. 이 과정은 시스템에 설치된 패키지의 최신 버전을 설치할 수 있도록 합니다.
    
    ```bash
    sudo apt-get update
    
    ```
    
2. **필수 패키지 설치**
    
    Docker 설치 및 인증서 관리를 위해 필요한 필수 패키지들을 설치합니다.
    
    ```bash
    sudo apt install apt-transport-https ca-certificates curl gnupg lsb-release -y
    
    ```
    
3. **Docker 안정 버전 저장소 추가**
    
    ```bash
    echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] <https://download.docker.com/linux/ubuntu> $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
    
    ```
    
4. **패키지 목록 업데이트 및 Docker 엔진 설치**
    
    ```bash
    sudo apt update
    sudo apt install docker-ce docker-ce-cli containerd.io -y
    
    ```
    
5. **(선택 사항) 현재 사용자를 Docker 그룹에 추가하여 sudo 없이 사용**
    
    ```bash
    sudo usermod -aG docker $USER
    
    ```
    
6. **Nginx 설치**
    - nginx 설치
    
    ```bash
    sudo apt install nginx -y
    
    ```
    
    - Nginx 서비스 시작 및 상태 확인
    
    ```bash
    sudo systemctl start nginx
    sudo systemctl status nginx
    
    ```
    
    - let’s Encrypt로 Certbot을 사용하여 SSL 인증서 발급 및 Nginx 설정 자동 구성
    
    ```bash
    sudo certbot --nginx -d i12c209.p.ssafy.io -d i12c209.p.ssafy.io
    
    ```
    
    - nginx.conf 설정
    
    ```bash
    user www-data;
    worker_processes auto;
    pid /run/nginx.pid;
    include /etc/nginx/modules-enabled/*.conf;
    
    events {
            worker_connections 768;
            # multi_accept on;
    }
    
    http {
    
            ##
            # Basic Settings
            ##
    
            sendfile on;
            tcp_nopush on;
            types_hash_max_size 2048;
            # server_tokens off;
    
            # server_names_hash_bucket_size 64;
            # server_name_in_redirect off;
    
            include /etc/nginx/mime.types;
            default_type application/octet-stream;
    
            ##
            # SSL Settings
            ##
    
            ssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3; # Dropping SSLv3, ref: POODLE
            ssl_prefer_server_ciphers on;
    
            ##
            # Logging Settings
            ##
    
            access_log /var/log/nginx/access.log;
            error_log /var/log/nginx/error.log;
    
            ##
            # Gzip Settings
            ##
    
            gzip on;
    
            # gzip_vary on;
            # gzip_proxied any;
            # gzip_comp_level 6;
            # gzip_buffers 16 8k;
            # gzip_http_version 1.1;
            # gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;
    
            ##
            # Virtual Host Configs
            ##
    
            include /etc/nginx/conf.d/*.conf;
            include /etc/nginx/sites-enabled/*;
    }
    
    #mail {
    #       # See sample authentication script at:
    #       # <http://wiki.nginx.org/ImapAuthenticateWithApachePhpScript>
    #
    #       # auth_http localhost/auth.php;
    #       # pop3_capabilities "TOP" "USER";
    #       # imap_capabilities "IMAP4rev1" "UIDPLUS";
    #
    #       server {
    #               listen     localhost:110;
    #               protocol   pop3;
    #               proxy      on;
    #       }
    #
    #       server {
    #               listen     localhost:143;
    #               protocol   imap;
    #               proxy      on;
    #       }
    #}
    
    ```
    
    - sistes-available 에 bgs 파일 생성 후 해당 코드 삽입
    /etc/nginx/sites-available/chaintoon
    
    ```bash
    server {
    # Docker 내장 DNS를 활용한 동적 네트워크
    resolver 127.0.0.11 valid=30s;
    
    server_name j12c109.p.ssafy.io;
    client_max_body_size 100M;
    
    location /api/nft/ {
        # express 는 static
        proxy_pass <http://express-container:3000/api/nft/>;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
    
    location /api/ {
        # be 는 static
        proxy_pass <http://be-container:8080/api/>;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
    
    location / {
        # fe 만 변수 사용 → 매 요청마다 DNS 재조회
        proxy_pass <http://fe-container:80/>;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        # 필요시
        # try_files $uri /index.html;
    }
    
    location /socket {
        proxy_pass <http://be-container:8080/socket>;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "Upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }
    
    location /jenkins/ {
        proxy_pass <http://jenkins-container:8080/jenkins/>;
        proxy_http_version 1.1;
        proxy_request_buffering off;
        proxy_set_header Host $host;
        proxy_set_header X-Forwarded-Host $host:$server_port;
        proxy_set_header X-Forwarded-Server $host;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
    }
    
    location /sonarqube/ {
        proxy_pass <http://sonarqube:9000/sonarqube/>;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
    
      listen 443 ssl; # managed by Certbot
      ssl_certificate     /etc/letsencrypt/live/j12c109.p.ssafy.io/fullchain.pem;
      ssl_certificate_key /etc/letsencrypt/live/j12c109.p.ssafy.io/privkey.pem;
      include             /etc/letsencrypt/options-ssl-nginx.conf;
      ssl_dhparam         /etc/letsencrypt/ssl-dhparams.pem;
    }
    
    server {
        if ($host = j12c109.p.ssafy.io) {
            return 301 https://$host$request_uri;
        }
        listen 80;
        server_name j12c109.p.ssafy.io;
        return 404;
    }
    
    ```
    

## 4. SSH 터널링으로 데이터베이스 연결하기

- Baston 서버를 활용한 RDS 연결

```bash
ssh -f -g -i SUPERAPP-User-S12P21C109-Key.pem -N -L 0.0.0.0:13306:rds-stg.ssafyapp.com:3306 toon109@15.164.101.122

```

- Baston 서버를 활용한 RDS 연결

```bash
ssh -f -g -i SUPERAPP-User-S12P21C109-Key.pem -N -L 0.0.0.0:16379:redis-stg.ssafyapp.com:6379 toon109@15.164.101.122

```

## 5. Docker 및 jenkins 설정

### Docker Image pull 받기

- JAVA
    
    ```bash
    docker pull bellsoft/liberica-openjdk-alpine:17.0.13
    
    ```
    
- node.js
    
    ```bash
    docker pull node:20-alpine
    
    ```
    
- nginx
    
    ```bash
    docker pull nginx:latest
    
    ```
    
- jenkins
    
    ```bash
    docker pull jenkins/jenkins:lts
    
    ```
    

### Jenkins 실행

1. **Jenkins 컨테이너 실행**
    
    Docker를 사용해 Jenkins를 설치하고 실행합니다. 이 컨테이너는 Jenkins 서버를 실행하며, 여러 마운트된 볼륨과 환경 변수를 사용해 설정됩니다.
    
    ```bash
    docker run -d --name jenkins \\\\\\\\
    -e TZ=Asia/Seoul \\\\\\\\
    -u root \\\\\\\\
    -p 8081:8080 \\\\\\\\
    -v /var/jenkins_home:/var/jenkins_home \\\\\\\\
    -v /var/run/docker.sock:/var/run/docker.sock \\\\\\\\
    -v /usr/bin/docker:/usr/bin/docker \\\\\\\\
    jenkins/jenkins:latest-jdk17
    
    ```
    
2. **Jenkins 컨테이너 실행 확인**
    
    Jenkins 컨테이너가 정상적으로 실행 중인지 확인합니다.
    
    ```bash
    sudo docker ps
    
    ```
    
    - 실행 중인 모든 Docker 컨테이너의 상태를 확인할 수 있습니다.

### Jenkins 초기 설정

1. **Jenkins 초기 비밀번호 확인**
    
    Jenkins 초기 설정을 위해, Jenkins 컨테이너의 로그에서 초기 관리자 비밀번호를 확인합니다. 이 비밀번호는 Jenkins 웹 인터페이스에 처음으로 로그인할 때 사용됩니다.
    
    ```bash
    sudo docker logs [Jenkins의 ContainerID]
    
    ```
    
    - `[Jenkins의 ContainerID]`는 실행 중인 Jenkins 컨테이너의 ID입니다.
2. **Jenkins Pipeline 구축**
    - **Credential 설정**: GitLab API Token을 발급받아 Jenkins의 Credential로 등록합니다.
    - **Pipeline 생성**: Jenkins Dashboard에서 새로운 Item을 생성하고, Pipeline 유형으로 설정합니다.
3. **Jenkins Pipeline Script 작성 및 실행**
    
    Jenkins 파이프라인 스크립트를 사용하여 다음 작업들을 자동화합니다:
    
    - Git 리포지토리에서 소스 코드 클론
    - Gradle을 사용하여 빌드
    - Docker 이미지를 빌드 및 실행
    - Docker 컨테이너 로그 확인

### frontend pipeline

```bash
pipeline {
    agent any

    tools {
        nodejs 'NodeJS 20.18.1'
    }

    stages {
        stage('Checkout') {
            steps {
                git branch: 'develop',
                    url: 'https://lab.ssafy.com/s12-blockchain-nft-sub1/S12P21C109.git',
                    credentialsId: 'gitlab'
            }
        }
        stage('Prepare .env') {
            steps {
                dir('FE') {
                    withCredentials([file(credentialsId: 'front-env', variable: 'ENV_FILE')]) {
                        sh 'rm -f .env && cp $ENV_FILE .env'
                    } 
                }
                
            }
        }

        stage('Build React') {
            steps {
                dir('FE') {
                    sh 'npm install && npm run build'
                }
            }
        }

        stage('Dockerize') {
            steps {
                dir('FE') {
                    sh '''
                        docker stop fe-container || true
                        docker rm fe-container || true
                        docker rmi fe-image || true
                        docker build -t fe-image .
                    '''
                }
            }
        }

        stage('Deploy') {
            steps {
                sh '''
                    docker run -d --name fe-container --network chaintoon_chaintoon-network -p 5173:80 fe-image
                '''
            }
        }
    }

    post {
        success {
            script {
                def user = sh(script: 'git log -1 --pretty=format:"%an"', returnStdout: true).trim()
                mattermostSend(color: 'good', message: "프론트엔드 서버 배포 성공. ${user}")
            }
        }
        failure {
            script {
                def user = sh(script: 'git log -1 --pretty=format:"%an"', returnStdout: true).trim()
                mattermostSend(color: 'danger', message: "프론트엔드 서버 배포 실패. 범인 : ${user}")
            }
        }
    }
}

```

### backend pipeline

```bash
pipeline {
    agent any
    
    tools {
        maven 'M3'
    }
    

    stages {
        stage('Checkout') {
            steps {
                git branch: 'develop',
                    url: 'https://lab.ssafy.com/s12-blockchain-nft-sub1/S12P21C109.git',
                    credentialsId: 'gitlab'
            }
        }
                
        stage('Prepare Config') {
            steps {
                // withCredentials로 secret 파일 경로를 받아옵니다.
                withCredentials([
                    file(credentialsId: 'application-prod', variable: 'APP_PROD'),
                    file(credentialsId: 'application-private', variable: 'APP_PRIVATE'),

                ]) {
                    script {
                        // config 디렉토리 생성 (존재하지 않으면)
                        sh 'mkdir -p BE/chaintoon/config'

                        // 자격증명 파일의 내용을 읽어 변수에 저장합니다.
                        def prodConfig = readFile(file: env.APP_PROD)
                        def privateConfig = readFile(file: env.APP_PRIVATE)
                        
                        // 읽어온 내용을 원하는 위치에 새 파일로 작성합니다.
                        writeFile file: 'BE/chaintoon/config/application.properties', text: prodConfig
                        writeFile file: 'BE/chaintoon/config/application-private.properties', text: privateConfig
                    }
                }
            }
        }
        

        stage('Build') {
            steps {
                dir('BE/chaintoon') {
                    sh 'mvn clean package -Dmaven.test.failure.ignore=true'
                }
            }
        }

        stage('Dockerize') {
            steps {
                dir('BE/chaintoon') {
                    sh '''
                        docker stop be-container || true
                        docker rm be-container || true
                        docker rmi be-image || true
                        docker build -t be-image .
                    '''
                }
            }
        }

        stage('Deploy') {
            steps {
                sh '''
                    docker run -d --name be-container \
                        -e TZ=Asia/Seoul \
                        --add-host=host.docker.internal:172.26.1.208 \
                        --network chaintoon_chaintoon-network \
                        -p 8080:8080 \
                        be-image
                '''
            }
        }
    }

    post {
        success {
            script {
                def user = sh(script: 'git log -1 --pretty=format:"%an"', returnStdout: true).trim()
                mattermostSend(color: 'good', message: "배포 성공. ${user}")
            }
        }
        failure {
            script {
                def user = sh(script: 'git log -1 --pretty=format:"%an"', returnStdout: true).trim()
                mattermostSend(color: 'danger', message: "배포 실패. 범인 : ${user}")
            }
        }
    }
}

```

### Express pipeline

```bash
pipeline {
    agent any

    tools {
        nodejs 'NodeJS 20.18.1'
    }

    stages {
        stage('Checkout') {
            steps {
                git branch: 'develop',
                    url: 'https://lab.ssafy.com/s12-blockchain-nft-sub1/S12P21C109.git',
                    credentialsId: 'gitlab'
            }
        }
        
        stage('Prepare .env') {
            steps {
                dir("nft"){
                    withCredentials([file(credentialsId: 'NFT-env', variable: 'ENV_FILE')]) {
                        sh 'rm -f .env && cp $ENV_FILE .env'
                    } 
                }
                
            }
        }

        stage('Install Dependencies') {
            steps {
                dir("nft") {
                    sh 'npm install'
                }
            }
        }

        stage('Dockerize') {
            steps {
                dir("nft"){
                    sh '''
                        # 기존 컨테이너 정리 (존재하면 종료 후 삭제)
                        docker stop express-container || true
                        docker rm express-container || true
                        docker rmi express-image || true
                        # Docker 이미지 빌드 (Dockerfile이 프로젝트 루트에 있어야 함)
                        docker build -t express-image .
                    '''
                }
            }
        }

        stage('Deploy') {
            steps {
                sh '''
                    # Express.js 서버를 백그라운드 실행, chaintoon-network 네트워크에 연결
                    docker run -d --name express-container \
                        -e TZ=Asia/Seoul \
                        --add-host=host.docker.internal:172.26.1.208 \
                        --network chaintoon_chaintoon-network \
                        -p 3000:3000 \
                        express-image
                '''
            }
        }
    }

    post {
        success {
            script {
                def user = sh(script: 'git log -1 --pretty=format:"%an"', returnStdout: true).trim()
                // mattermostSend 플러그인이나 알림 도구를 사용하여 성공 메시지 전송
                mattermostSend(color: 'good', message: "Express.js 서버 배포 성공. ${user}")
            }
        }
        failure {
            script {
                def user = sh(script: 'git log -1 --pretty=format:"%an"', returnStdout: true).trim()
                mattermostSend(color: 'danger', message: "Express.js 서버 배포 실패. 범인 : ${user}")
            }
        }
    }
}

```

### 도메인에 ssl 적용하기

```bash
sudo apt install certbot python3-certbot-nginx -y
sudo certbot --nginx -d j12c109.p.ssafy.io
```

### Docker Compose 설치

1. **Docker Compose 다운로드**
    
    Docker Compose 바이너리를 `/usr/local/bin` 디렉토리에 다운로드합니다. 이 경로는 시스템 전역에서 실행할 수 있도록 설정된 디렉토리입니다.
    
    ```bash
    sudo curl -SL <https://github.com/docker/compose/releases/download/v2.28.1/docker-compose-linux-x86_64> -o /usr/local/bin/docker-compose
    
    ```
    
2. **Docker Compose 실행 권한 부여**
    
    Docker Compose 파일에 실행 권한을 부여합니다. 이를 통해 명령어로 Docker Compose를 실행할 수 있게 됩니다.
    
    ```bash
    sudo chmod +x /usr/local/bin/docker-compose
    
    ```
    
3. **Docker Compose 심볼릭 링크 생성**
    
    Docker Compose의 심볼릭 링크를 `/usr/bin` 디렉토리에 생성하여, 명령어로 실행할 수 있도록 설정합니다.
    
    ```bash
    sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose
    
    ```
    
4. **Docker Compose 설치 확인**
    
    Docker Compose가 정상적으로 설치되었는지 확인하기 위해 버전을 출력합니다.
    
    ```bash
    docker-compose -v
    
    ```
    
5. **docker-compose.yml**
    
    ```bash
    version: '3.8'
    
    services:
      jenkins:
        image: jenkins/jenkins:lts
        container_name: jenkins-container
        group_add:
          - "122" # 호스트 docker 그룹 ID
        ports:
          - "50000:50000"
          - "8081:8080"
        volumes:
          - /home/jenkins:/var/jenkins_home
          - /usr/bin/docker:/usr/bin/docker
          - /var/run/docker.sock:/var/run/docker.sock
          - /etc/localtime:/etc/localtime:ro  # 호스트의 타임존 정보 마운트
        environment:
          - TZ=Asia/Seoul
          - JENKINS_OPTS= --prefix=/jenkins
          - JENKINS_SLAVE_AGENT_PORT=50000
        restart: unless-stopped
        networks:
          - chaintoon-network   # <--- 사용자 정의 네트워크를 사용하도록 명시
    
      nginx:
        image: nginx:latest
        container_name: nginx-container
        ports:
          - "80:80"
          - "443:443"
        volumes:
          - /home/ubuntu/conf.d/nginx.conf:/etc/nginx/nginx.conf:ro
          - /etc/nginx/sites-available/:/etc/nginx/sites-available/:ro
          - /etc/nginx/sites-enabled/:/etc/nginx/sites-enabled/:ro
          - /etc/letsencrypt:/etc/letsencrypt:ro
          - /etc/localtime:/etc/localtime:ro
        environment:
          - TZ=Asia/Seoul
        restart: unless-stopped
        networks:
          - chaintoon-network
      sonarqube:
        image: sonarqube:latest
        container_name: sonarqube
        ports:
          - "9200:9000"
        volumes:
          - sonarqube_data:/opt/sonarqube/data
          - sonarqube_extensions:/opt/sonarqube/extensions
          - sonarqube_logs:/opt/sonarqube/logs
          - sonarqube_temp:/opt/sonarqube/temp
        environment:
          - TZ=Asia/Seoul
          - SONAR_WEB_CONTEXT=/sonarqube
        restart: unless-stopped
        networks:
          - chaintoon-network
    volumes:
      sonarqube_data:
      sonarqube_extensions:
      sonarqube_logs:
      sonarqube_temp:
    
    # =========================
    # 네트워크 정의 섹션
    # =========================
    networks:
      chaintoon-network:
        driver: bridge
    
    ```
    
    ### docker-compose 파일 실행
    
    - docker-compose.yml 파일이 있는 경로에서 해당 명령어 실행
    
    ```bash
    docker-compose up -d
    
    ```
    
    - docker-compose 파일 중단
    
    ```bash
    docker-compose down
    
    ```
    

## 4. properties 파일

- application.properties
    
    ```bash
    spring.application.name=chaintoon
    
    # MySQL
    spring.datasource.url=jdbc:mysql://host.docker.internal:13306/toon109?useSSL=false&serverTimezone=Asia/Seoul&allowPublicKeyRetrieval=true
    spring.datasource.username=toon109
    spring.datasource.password=바스티온 서버 pw
    spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
    
    # JPA
    spring.jpa.hibernate.ddl-auto=none
    spring.jpa.database-platform=org.hibernate.dialect.MySQL8Dialect
    
    # HikariCP
    spring.datasource.hikari.maximum-pool-size=10
    # Request Size
    spring.servlet.multipart.max-file-size=100MB
    spring.servlet.multipart.max-request-size=100MB
    
    server.servlet.session.cookie.secure=true
    server.servlet.session.cookie.same-site=None
    
    logging.level.org.springframework=INFO
    
    spring.profiles.include=private
    ```
    
- application-private.properties
    
    ```bash
    # SMTP
    spring.mail.host=smtp.gmail.com
    spring.mail.port=587
    spring.mail.username=chaintoon109@gmail.com
    spring.mail.password=
    spring.mail.properties.mail.smtp.auth=true
    spring.mail.properties.mail.smtp.starttls.enable=true
    spring.mail.properties.mail.smtp.ssl.protocols=TLSv1.2
    
    # Redis
    spring.data.redis.host=host.docker.internal
    spring.data.redis.port=16379
    spring.data.redis.password=
    
    # JWT
    jwt.secret-key-access=fgQwCb4P18YvzXF24dmGlsdNkVAScCYI
    
    jwt.access-token-validity-in-ms: 604800000
    
    # aws
    cloud.aws.credentials.access-key=AKIAW7FB3555LMSBWRNU
    cloud.aws.credentials.secret-key=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
    cloud.aws.region.static=ap-northeast-2
    cloud.aws.s3.bucket=ssafyapp-stg-project-prv-data/967wcr/
    cloud.aws.s3.presigned-url.expiry=30
    cloud.aws.stack.auto=false
    
    # SSAFY SSO Login Config
    sso.ssafy.client-id=a522cc98-4165-43c8-9e7e-fad41d84c7a4
    sso.ssafy.client-secret=8e171726-0824-4bcb-ab42-3c485ad24a3f
    sso.ssafy.redirect-uri=https://j12c109.p.ssafy.io/sso/providers/ssafy/callback
    sso.ssafy.authorization-uri=https://project.ssafy.com/oauth/sso-check
    sso.ssafy.token-uri=https://project.ssafy.com/ssafy/oauth2/token
    sso.ssafy.user-info-uri=https://project.ssafy.com/ssafy/resources/userInfo
    ```
    
- back-end Dockerfile
    
    ```bash
    # Use an official Liberica runtime as a parent image
    FROM bellsoft/liberica-openjdk-alpine:17.0.13
    
    # Install FFmpeg using apk
    RUN apk update && apk add --no-cache ffmpeg
    
    # Set the working directory
    WORKDIR /app
    
    # Copy the JAR file into the container
    COPY target/chaintoon.jar app.jar
    
    # Copy properties files to a specific directory
    COPY config/application.properties /app/config/application.properties
    COPY config/application-private.properties /app/config/application-private.properties
    
    # Expose the port the app runs on
    EXPOSE 8080
    
    # Run the application
    ENTRYPOINT ["java", "-jar", "/app/app.jar", "--spring.config.location=/app/config/application.properties"]
    ```
    
- front-end Dockerfile
    
    ```bash
    # 1단계: 빌드 단계 (Node 20-alpine 사용)
    FROM node:20-alpine AS builder
    WORKDIR /app
    COPY package.json package-lock.json* ./
    RUN npm install
    COPY . .
    RUN npm run build
    
    # 2단계: Nginx를 이용한 프로덕션 환경 구축
    FROM nginx:stable-alpine
    # 빌드된 파일을 Nginx의 기본 루트 디렉토리로 복사
    COPY --from=builder /app/dist /usr/share/nginx/html
    # 커스텀 Nginx 설정 복사: 예를 들어, SPA를 위한 fallback 설정을 적용
    COPY config/nginx.conf /etc/nginx/conf.d/default.conf
    
    EXPOSE 80
    CMD ["nginx", "-g", "daemon off;"]
    
    ```
    
- express Dockerfile
    
    ```bash
    # 베이스 이미지는 Node.js LTS 버전 (예: 14-alpine)
    FROM node:18-alpine
    
    # 작업 디렉토리 설정
    WORKDIR /app
    
    # package.json과 package-lock.json을 먼저 복사하여 의존성 설치 캐싱 활용
    COPY package*.json ./
    
    # 프로덕션용 의존성 설치 (테스트용은 별도 처리 가능)
    RUN npm install --production
    
    # 앱 소스 복사
    COPY . .
    
    # Express.js 서버 포트 노출 (예: 3000)
    EXPOSE 3000
    
    # 앱 실행 (entrypoint는 server.js 혹은 app.js 등 실제 파일명으로 수정)
    CMD ["node", "server.js"]
    
    ```
    
- front .env 파일
    
    ```bash
    VITE_CHAINTOON_BASE_URL=https://j12c109.p.ssafy.io/api
    ```
    
- truffle env 파일
    
    ```bash
    MNEMONIC="관리자 지갑 복구문"
    ```
    
- express.js .env 파일
    
    ```bash
    # .env 파일 예시
    # RPC_URL=https://ethereum-holesky.publicnode.com
    # RPC_URL=https://rpc.ankr.com/eth_holesky
    RPC_URL=https://multi-holy-season.ethereum-holesky.quiknode.pro/09723c9af9caab038b9ca7e4ac263a1382753ca2
    SERVER_PRIVATE_KEY=0x3fe0225b71f3f06b421f053ffb4165facb7653bbf2f73bcc8116449f85342b94
    WALLET_CONTRACT_ADDRESS=0x037D24b0dbF5BC73807dC5feEa47D6D8F956226b
    NFT_MARKETPLACE_ADDRESS=0x22f4Ced20bceE951517Ca68dc4a123609aB55B94
    SUPPER_APP_NFT_ADDRESS=0x9897707d1D71753ac10f9559e501602476432988
    # INFURA API KEY
    INFURA_API_KEY=f1ddfb5e434c4d78b6f776ea1a8f1f8f
    
    # DB 관련
    DB_HOST=host.docker.internal
    DB_PORT=13306
    DB_USER=toon109
    DB_PASSWORD=바스티온 서버 비밀번호
    DB_NAME=toon109
    
    # NFT 민팅 및 IPFS 업로드 관련
    PINATA_API_KEY=Pinata API 키
    PINATA_SECRET_API_KEY=Pinata secret 키
    
    IPFS_GATEWAY=https://gateway.pinata.cloud/ipfs/
    
    # REDIS 관련
    REDIS_URL=redis://host.docker.internal:16379
    REDIS_PASSWORD=
    
    PORT=3000
    ENCRYPTION_KEY=e3f94b8c2a1d0f7e6c5b4a3f2910b8d7e6c5d4f3a9b1c0d9e8f1a6b5c4d3e2ff
    # 비대칭 암호화 키
    # Admin Wallet
    ADMIN_WALLET_ADDRESS=관리자 지갑 주소
    
    # JWT Secret Key
    JWT_SECRET_KEY=fgQwCb4P18YvzXF24dmGlsdNkVAScCYI
    
    # Ehterscan API
    ETHERSCAN_API_KEY=holesky etherscan api 키
    FIRST_SYNC_BLOCK=3600000
    ```