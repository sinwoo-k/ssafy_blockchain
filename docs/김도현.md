## 블록체인이 탄생한 배경 및 과정
- 블록체인은 비트코인에서 파생된 기술이다.
- 비트코인은 기존의 중앙화된 시스템을 부수기 위해서 만들어진 디지털 화페이다.
- 과거에는 금본위제를 사용하여 금을 담보로 화페를 발행했음
- 현재는 신용화페로 정부가 화페에 대한 가치를 보증하면서 발행함
    - 이는 결국 금이 아닌 중앙화된 기관의 데이터베이스에 의해서 관리됨
        - ex) 현시대의 대다수의 사람들은 현금이 아닌 디지털 자산 즉 뱅킹 시스템에 적힌 디지털들을 화페로 사용하고 있음 이는 결국 중앙화된 기관의 데이터베이스에 CRUD랑 다를게 없음 → 이를 모두가 투명하게 보고 모두가 관리할 수 있는 분산원장 기술을 쓰자
    - 이에대한 문제점으로 화페를 무분별하게 찍어내면서 인플레이션이 증가하고 중앙화된 기관에 대한 권력 강화, 화페 가치 하락 등 여러 문제점들이 생김
    - 이를 탈중앙화 시스템으로 보다 안전하고 투명하게 관리하자 해서 나온게 비트코인임
- 탈중앙화된 시스템인 비트코인을 사용하자
    - 어떻게 탈중앙화된 시스템으로 구현을 하느냐
    - 모두가 분산된 노드를 가지고 있어서 투명한 장부 관리가 됨
    - 발행 또한 POW = 일을 가장 많이 한 사람한테 이에 대한 보상으로 비트코인을 준다
    - 투명하고 주는 방식은 알겠지만 무슨 가치를 가지냐? 라고 했을때 가치가 없음
    - 그래서 이를 정의하자는거임
- 비트코인은 금과 같은 성질을 가짐 → 디지털 금이라고 불림
    
 ![](https://velog.velcdn.com/images/numdo/post/3dfeebc5-9256-4a86-8fef-f49ede8b4fc4/image.png)
    
- P2P 전달 방식의 예제

  ![](https://velog.velcdn.com/images/numdo/post/b9c8e6e1-b003-47cb-82a2-110535205efa/image.png)


## 사전학습 실습

### Solidity에 대한 기본적인 문법 학습

- **기본 구조 및 선언**
  - **컨트랙트 선언:** Solidity 코드는 `contract ContractName { ... }` 형태로 시작하며, 하나의 컨트랙트는 클래스처럼 상태 변수, 함수, 이벤트 등을 포함합니다.
  - **버전 지정:** 파일 상단에 `pragma solidity ^0.8.0;` 와 같이 컴파일러 버전을 지정합니다.

- **상태 변수와 자료형**
  - **자료형:** 정수(`uint`, `int`), 불리언(`bool`), 주소(`address`), 문자열(`string`) 등 다양한 타입을 지원하며, 변수 선언 시 타입을 명시해야 합니다.
  - **상태 변수:** 컨트랙트의 상태를 저장하는 변수로, 블록체인 상에 영구적으로 저장됩니다.

- **함수와 가시성**
  - **함수 선언:** `function 함수명(매개변수) public view returns(반환타입) { ... }` 형태로 선언하며, public, private, internal, external 등의 가시성 지정자가 사용됩니다.
  - **리턴 값:** 복수의 반환값도 지원하며, 튜플 형태로 반환할 수 있습니다.

- **생성자와 초기화**
  - **생성자:** 컨트랙트 배포 시 한 번 호출되는 특별한 함수로, 최신 버전에서는 `constructor() { ... }` 형태로 작성합니다.

- **이벤트와 로그**
  - **이벤트 선언:** `event EventName(매개변수들);` 형태로 선언하며, 트랜잭션 로그를 남겨 나중에 이벤트를 통해 상태 변화를 추적할 수 있습니다.
  - **이벤트 호출:** `emit EventName(값들);`로 이벤트를 발생시킵니다.

- **제어문 및 에러 처리**
  - **조건문 및 반복문:** JavaScript나 다른 C 계열 언어와 유사한 `if`, `for`, `while` 문을 지원합니다.
  - **에러 처리:** `require()`, `revert()`, `assert()` 등을 사용해 조건 검사 및 오류 발생 시 처리를 할 수 있습니다.

- **수정자(Modifier)**
  - **함수 실행 전/후 조건 추가:** 수정자는 함수 호출 전에 조건을 체크하거나 로직을 추가할 때 사용되며, 코드 재사용 및 보안 강화를 도모합니다.

- **상속과 인터페이스**
  - **상속:** 여러 컨트랙트를 상속받아 코드 재사용이 가능하며, 다중 상속도 지원합니다.
  - **인터페이스:** 컨트랙트 간의 인터페이스를 정의해, 구현을 강제할 수 있습니다.


### 배포 과정 실습 내용

- 계약 작성: 기본적인 상태 변수, 함수, 이벤트 등을 포함한 스마트 컨트랙트를 작성.

- 컴파일: Remix의 Solidity 컴파일러를 통해 코드의 문법과 타입 오류를 점검.

- 환경 선택: 배포를 위한 네트워크를 선택(예: JavaScript VM을 통한 로컬 테스트 또는 MetaMask를 통한 실제 네트워크).

- 배포: 'Deploy & Run Transactions' 탭을 이용해 계약을 배포하고, 배포 후 제공되는 인터페이스를 통해 함수 호출 등의 상호작용을 실습.

- 결과 확인: 배포된 컨트랙트의 주소와 상태를 확인하며, 실제 이더리움 네트워크 상에서 계약이 어떻게 작동하는지 검증.

- 실제 배포: 테스트넷에서 지갑을 통해 배포를 해보려고 하였으나, 지갑에 이더리움을 소유하여야지만 테스트넷 이더리움을 받을 수 있어서 해보지 못하였음음
